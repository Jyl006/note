### 引擎
- 语法
	- 查看引擎的语法 -- `show engines;`
	- 在创建表时指定引擎 -- 
		- `create table emp_name(...) engine = [指定引擎]`
##### 存储引擎特点
###### InnoDB
- 介绍
	- InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5 之后，InnoDB是默认的 MySQL 存储引擎。
- **特点**
	1. DML操作遵循ACID模型，支持事务；
	2. 行级锁，提高并发访问性能；
	3. 支持外键 FOREIGN KEY约束，保证数据的完整性和正确性；
- 文件
	- xxx.idb：InnoDB引擎每张表都会对应一个这样的表空间文件，存储该表结构（frm、sdi）、数据和索引。
	- 参数（表和表空间一对一）：innodb_file_per_table
- 逻辑存储结构
	- TbaleSpece：表空间
	- Segment：段
	- Exgment：区
	- Page：页
	- Row：行
###### MyISAM
- 介绍
	- 是MySQL的早期引擎
- **特点**
	1. 不支持事务，不支持外键
	2. 支持表锁，不支持行锁
	3. 访问速度快、
- 文件
	- xxx.sdi：存储表结构信息
	- xxx.MYD：存储数据
	- xxx.MYI： 存储索引
###### Memory
- 介绍
	- Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。
- 特点
	- 内存存放
	- hash索引(默认)
- 文件
	- xxx.sdi：存储表结构信息
##### 存储引擎选择
在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组
- InnoDB：是MySQL的默认存储引擎，支持事务、外键。如果**应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作**，那么InnoDB存储引擎是比较合适的选择。
- MyISAM ：如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于**临时表及缓存**。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。
---
### 索引
- 概述：
	索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

---

#### 索引语法
###### 创建索引
- 定义普通索引
``` mysql
CREATE TABLE table_name (
    column3 datatype,
    ...,
    INDEX index_name (column3)
);
```

``` mysql
ALTER TABLE table_name ADD INDEX index_name (column);
```
--- 
- 定义全文索引
```mysql
CREATE TABLE table_name (
    column5 TEXT,
    column6 TEXT,
    ...,
    FULLTEXT ft_index_name (column5, column6)
);
```

```mysql
ALTER TABLE table_name ADD FULLTEXT ft_index_name (column1, column2);
```

- **添加唯一索引:**
```mysql
ALTER TABLE table_name ADD UNIQUE unique_index_name (column);
```

- 添加主键索引 (如果表中还没有主键):
```mysql
ALTER TABLE table_name ADD PRIMARY KEY (column);
```

- **添加复合索引:**
```mysql
ALTER TABLE table_name ADD INDEX composite_index_name (column1, column2, column3);
```
 (在括号中按顺序指定需要添加到复合索引中的列)
###### 删除索引
- **删除普通索引、唯一索引、全文索引:**
```mysql
ALTER TABLE table_name DROP INDEX index_name;
```

- 删除主键索引
```mysql
ALTER TABLE table_name DROP PRIMARY KEY;
```

###### 查看索引
```mysql
SHOW INDEX FROM table_name;
```







#### 联合索引

**是什么：** 在表的**多个列**上创建的一个索引。

**主要目的：** 优化涉及多个列的查询，例如 `WHERE col1 = val1 AND col2 = val2` 或 `ORDER BY col1, col2`。

**核心原则：最左前缀原则 (Leftmost Prefix Principle)**

- **含义：** 查询必须使用索引中的**最左边列**，或者使用**从最左边开始连续**的几列，索引才能被有效利用。
- **示例：** 在 `(A, B, C)` 上建联合索引。
    - 查询条件包含 `A`：可以使用索引的 `A` 部分。
    - 查询条件包含 `A` 和 `B`：可以使用索引的 `A, B` 部分。
    - 查询条件包含 `A`, `B`, `C`：可以使用索引的 `A, B, C` 全部。
    - 查询条件只包含 `B` 或 `C`：**无法**使用这个联合索引。
    - 查询条件包含 `A` 和 `C` (跳过 `B`)：**只能**使用索引的 `A` 部分，`C` 部分无法利用索引。

**工作方式 (简记):** 索引按照指定的列顺序存储和排序数据（先按第一个列，再按第二个列...）。最左前缀原则是因为索引是按这个顺序构建的。

**优点：**

- 提高多条件查询 (`AND`) 的效率。
- 优化多列排序 (`ORDER BY`) 和分组 (`GROUP BY`)。
- 可能实现**覆盖索引**，提高查询速度（如果查询只选取索引中的列）。

**关键：**

- **列的顺序非常重要！** 需要根据最频繁的查询条件来设计列的顺序（通常把最常用的过滤列放在最左边）。
- 和所有索引一样，会增加写操作 (INSERT, UPDATE, DELETE) 的开销和存储空间。

**简记：** **多列索引**，遵循**最左前缀**，用来加速**多条件查、排序、分组**。

---
#### 聚簇索引和二级索引

**核心存储引擎：InnoDB** (MySQL 默认且常用，主要讨论 InnoDB 的索引特性)

**1. 聚簇索引 (Clustered Index)**

- **是什么：** 它**不是一个独立于数据之外的索引**，而是数据行本身按照某个顺序（通常是主键顺序）物理存储的方式。**表的数据行就存储在聚簇索引的叶子节点中。**
- **基于什么：** 通常是基于**主键 (PRIMARY KEY)** 构建。
	如果表没有显式定义主键，InnoDB 会选择一个唯一的非空索引作为聚簇索引；
	如果没有这样的索引，InnoDB 会隐式创建一个隐藏的聚簇索引。
- **数量：** **一个表只能有一个聚簇索引**，因为它决定了数据行的物理存储顺序。
- **特点：**
    - 数据行与索引紧密关联，查询速度非常快（如果查询条件是主键）。
    - 非叶子节点存储索引键值和指向下层节点的指针。叶子节点存储**完整的行数据**。

**简记：** **数据本身就是索引**，按主键排序并存储。**一个表一个**。

**2. 二级索引 (Secondary Index / Non-clustered Index)**

- **是什么：** 它是一个**独立于数据之外的索引结构**。它的叶子节点存储的不是完整的行数据。
- **基于什么：** 可以基于一个或多个**非主键列**创建（普通索引、唯一索引、联合索引、全文索引等）。
- **数量：** **一个表可以有多个二级索引**。
- **特点：**
    - 非叶子节点存储索引键值和指向下层节点的指针。
    - 叶子节点存储索引键值和对应的**主键值**。
    - 通过二级索引查找数据时，首先根据索引键值找到对应的**主键值**，然后**再根据这个主键值去聚簇索引中查找完整的行数据**。这个“根据主键值再查找一次”的过程叫做**“回表”(Lookup)**。

**简记：** **指向数据的索引**，叶子节点存的是**主键值**。**一个表多个**。通过二级索引查数据需要**“回表”**。

**核心区别回顾：**

|          |                            |                                |
| -------- | -------------------------- | ------------------------------ |
| **特性**   | **聚簇索引 (Clustered Index)** | **二级索引 (Secondary Index)**     |
| **数据存储** | **包含完整的行数据**               | **只包含索引键值和主键值**                |
| **数量**   | **一个表只能有一个**               | **一个表可以有多个**                   |
| **查找过程** | 直接定位到数据行                   | 先定位到主键值，再通过主键去聚簇索引查数据 (**回表**) |
| **物理顺序** | 决定数据行的物理存储顺序               | 不决定数据行的物理存储顺序                  |
| **通常基于** | **主键**                     | 非主键列                           |

---
#### 前缀索引

**是什么：** 在字符串类型的列（如 `VARCHAR`, `TEXT` 等）上，只对列值的**前 N 个字符**建立索引，而不是对整个列值建立索引。

**主要目的：**

- **节省索引空间：** 当字符串列非常长时，只索引前缀可以大大减小索引文件的大小。
- **提高索引效率：** 更小的索引意味着更高的缓存命中率，以及在 B+ Tree 中遍历的节点更少，从而可能提高查询速度。

**语法：**

在创建索引时，在列名后的括号中指定前缀的长度（字符数）。

```mysql
-- 在 ALTER TABLE 中添加前缀索引
ALTER TABLE table_name ADD INDEX index_name (column_name(prefix_length));

-- 在 CREATE TABLE 中定义前缀索引
CREATE TABLE table_name (
    column_name VARCHAR(255),
    ...,
    INDEX index_name (column_name(prefix_length))
);
```

- `column_name`: 要创建前缀索引的字符串列。
- `prefix_length`: 指定索引前缀的字符数。

**适用场景：**

- 字符串列的长度较长。
- 列值的**前缀**具有足够高的**选择性（Cardinality）**，即前 N 个字符的组合值能够比较好地区分不同的行。如果前缀的选择性太低（很多不同的完整字符串有相同的前缀），那么索引效果会大打折扣。

**局限性：**

- **无法用于 `ORDER BY`：** 如果查询需要按照该列进行排序，且排序依赖于前缀以外的字符，则无法利用此前缀索引进行排序优化。
- **无法作为覆盖索引：** 如果查询需要返回该列的完整值，即使使用了前缀索引，也需要回表获取完整的列值。

**如何选择前缀长度 (`prefix_length`)：**

这是一个权衡。前缀越长，选择性通常越高（更能区分不同的值），但索引也越大。通常可以通过计算不同前缀长度的选择性来决定一个合适的长度。一个常用的方法是找到一个前缀长度，使得其选择性接近于完整列的选择性。

- **检查选择性示例 (找到一个合适的前缀长度 N)：**
    
    ```mysql
    -- 计算完整列的选择性
    SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
    
    -- 计算前 N 个字符的选择性
    SELECT COUNT(DISTINCT LEFT(column_name, N)) / COUNT(*) FROM table_name;
    ```
    
    尝试不同的 `N` 值，找到一个选择性接近完整列，但 `N` 又相对较小的值。

**简记：** **只索引长字符串的开头部分**，**省空间提效率**。语法是 `列名(长度)`。关键是**选对长度**，保证**前缀选择性**。不能用于**完整列排序**。

---
#### 索引失效

**索引失效：** 指尽管表上存在可用的索引，但 MySQL 的查询优化器在执行查询时选择不使用该索引（或者只使用了索引的一部分），导致查询性能下降。这通常是由于 SQL 语句的写法或数据特性导致的。

**根本原因：** 查询优化器认为使用索引的成本比全表扫描或使用其他方式更高，或者 SQL 语句的写法阻止了优化器使用索引。

**常见导致索引失效的原因：**

1. **对索引列进行函数操作或计算：**
    
    - **示例：** `WHERE YEAR(create_time) = 2023` 或 `WHERE age + 1 = 30`
    - **原因：** 数据库需要先计算 `YEAR(create_time)` 或 `age + 1`，然后用计算结果去和常数比较。计算后的值无法直接匹配索引中的原始列值。
2. **字符串不加单引号**
3. **SQL提示：**
	`use index:`建议使用索引
		`explain select * from tb user use index(idx user pro) where profession ='软件工程'`
	`ignore index:`不使用索引
		`explain select * from tb userignore index(idx user pro) where profession =`软件工程'`
	`force index:`强制使用索引
		`explain select * from tb userforce index(idx user pro) where profession='软件工程`
	
4. **在 `LIKE` 条件中使用前导通配符 (`%`)或者进行头部模糊匹配：**
    
    - **示例：** `WHERE user_name LIKE '%张三'` 或 `WHERE user_name LIKE '%张三%'`
    - **原因：** 索引是按照值的开头进行排序的。前导通配符使得数据库无法确定从索引的哪个位置开始查找，只能进行全索引扫描（如果是覆盖索引）或全表扫描。
    - **例外：** `LIKE '张三%'` (没有前导通配符) 可以使用索引。
5. **违背最左前缀原则 (针对联合索引)：**
    
    - **示例：** 在 `(col1, col2, col3)` 上有联合索引，但查询条件只有 `WHERE col2 = val2` 或 `WHERE col1 = val1 AND col3 = val3`。
    - **原因：** 联合索引是按照从左到右的顺序建立的。如果查询没有从索引的最左边列开始，或者跳过了中间的列，索引就无法被充分利用（可能完全失效，或只能使用部分最左边的列）。
6. 使用 `OR` 连接不同的索引列 (有时会失效)：
    
    - **示例：** `WHERE column1 = value1 OR column2 = value2` (column1 和 column2 分别有单列索引)
    - **原因：** 如果 `OR` 连接的条件涉及不同的索引列，并且优化器认为合并多个索引的结果集效率不高时，可能会放弃使用索引而进行全表扫描。**但也存在“索引合并”或“OR Expansion”等优化手段，不总是失效**，取决于 MySQL 版本和优化器判断。
7. 使用 `NOT IN` 或 `<>` / `!=` (有时会失效)：
    
    - **示例：** `WHERE status != 'completed'` 或 `WHERE user_id NOT IN (1, 2, 3)`
    - **原因：** 如果不等于/不在某个集合内的结果集占总数据的大多数，优化器可能认为全表扫描比使用索引回表更高效。
8. 对索引列进行隐式类型转换：
    
    - **示例：** `WHERE string_column = 123` (string_column 是字符串类型，但与数字比较)
    - **原因：** MySQL 在比较时可能会将索引列进行类型转换，这会使索引失效，类似于对索引列使用了函数。
9. `IS NULL` 或 `IS NOT NULL` (取决于索引类型和列特性)：
    
    - **原因：** 对于某些索引类型或某些版本的 MySQL，`IS NULL` 或 `IS NOT NULL` 可能无法有效利用索引。但在现代 MySQL 版本和 InnoDB 中，如果列允许 NULL 并且索引包含 NULL 值，`IS NULL` 通常可以使用索引，而 `IS NOT NULL` 的效果取决于 NULL 值的比例和优化器判断。
10. **优化器判断全表扫描更高效：**
    
    - **原因：** 如果表的数据量很小，或者查询需要返回表中绝大多数行，MySQL 优化器可能会认为直接全表扫描比走索引更块（因为走索引需要额外的数据读取和回表操作）。

**如何判断是否失效：**

- 使用 `EXPLAIN` 命令分析查询计划。查看输出中的 `key` 列是否为 `NULL`，以及 `type` 列是否为 `ALL` 或 `index` (非覆盖索引)。

**如何避免/解决：**

- **改写 SQL 语句：** 避免在索引列上使用函数、计算，避免前导通配符，遵循最左前缀原则等。
- **创建合适的索引：** 根据查询模式创建单列索引或联合索引。
- **统一数据类型：** 确保 WHERE 子句中比较的列和值的数据类型一致。
- **分析数据分布：** 理解数据的特点有助于判断优化器的选择。
- **使用 `EXPLAIN` 验证：** 每次优化后都使用 `EXPLAIN` 检查索引是否被正确使用。

**简记：** **操作索引列、前缀符LIKE、违背最左、类型转换、优化器觉得慢**，这些是索引失效常见原因。**看EXPLAIN的key和type**来判断。
简记：索引失效：1、函数运算，2、字符串加引号，3、like模糊匹配，4、or连接的条件，5、全表扫描比索引扫描快

---
#### 索引设计原则
1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件(where)、排序(orderby)、分组(group by)操作的字段建立索引:
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NLLL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。
---
### SQL性能分析
##### 查询语句
- 提供服务器状态信息 -- `show [session | global] status`
	- 查看当前数据库的命令访问频次 --  `show global status like 'Com__'` 
	  *'Com__'是模糊匹配*

##### 慢日志查询

**概念：**
- 慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位:秒，默认10秒)的所有SQL语句的日志。

- MySQL的慢查询日志默认没有开启，需要在MySQL的**配置文件(/etc/my.cnf)**中配置如下信息:**
```mysql
# 开启MySOL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SOL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```
**或者执行命令(临时生效)：**
```mysql
# 开启MySOL慢日志查询开关
set global slow_query_log=1;  
# 设置慢日志的时间为2秒，SOL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
set global long_query_time=2;
```

##### profiles查询分析器

***是什么：*** 一个内置工具，用于**详细分析某一条具体 SQL 语句**在服务器内部执行时，在**各个阶段**所花费的时间。

***目的：*** 精确地找出一条查询语句的**性能瓶颈**，了解时间主要耗费在哪一步（如解析、优化、打开表、访问索引、排序、发送数据等）。

*可用性检查：*

- 查看系统变量 `have_profiling` 的值。
    
    ```mysql
    SHOW VARIABLES LIKE 'have_profiling';
    ```
    
- 如果结果是 `YES`，则表示功能可用。

*基本使用步骤：*

1. **开启 profiling 功能：**
    
    ```mysql
    SET profiling = 1; -- 或 SET profiling = ON;
    ```
    
    (注意：开启后，当前会话执行的查询都会被记录)
    
2. **执行你要分析的 SQL 语句：**
    
    ``` mysql
    SELECT ... FROM ... WHERE ...; -- 运行你的目标查询
    ```
    
3. **查看最近执行的查询列表及其总耗时：**
    
    ``` mysql
    SHOW PROFILES;
    ```
    
    找到你刚刚执行的那条查询对应的 `Query_ID`。
    
4. **查看特定查询的详细执行阶段耗时：**
    
    ``` mysql
    SHOW PROFILE FOR QUERY [Query_ID]; -- 将 [Query_ID] 替换为上一步找到的 ID
    ```
    
    - 输出会列出查询执行经过的每个阶段 (State) 以及在该阶段花费的时间 (Duration)。常见的阶段如 `starting`, `checking permissions`, `Opening tables`, `System lock`, `init`, `optimizing`, `preparing`, `executing`, `Sending data`, `end`, `closing tables`, `freeing items` 等等。
    
5. **关闭 profiling 功能 (建议在分析完成后关闭)：**
    
    ``` mysql
    SET profiling = 0; -- 或 SET profiling = OFF;
    ```
    

***与慢查询日志的关系 (简记):***

- **慢查询日志：** 找到**哪些**查询是慢的 (关注结果)。
- **查询分析器：** 分析**为什么**特定的某个查询是慢的 (关注过程)。

**简记：** **单条查询**的**执行阶段耗时分析**工具。开启->执行->看列表->看详情->关闭。帮你定位查询**慢在哪一步**。

##### explain执行计划

**是什么：** 一个 SQL 命令，用来**查看 MySQL 数据库如何计划执行一条 SQL 语句**（主要是 SELECT 语句，但也可用于 INSERT, UPDATE, DELETE）。它不会真正执行查询，而是展示数据库的执行策略。

**目的：** 理解查询的执行过程，判断是否使用了预期的索引，找出潜在的性能问题，为优化提供依据。

**基本用法：**

在你要分析的 SQL 语句前面加上 `EXPLAIN` 关键字即可。

``` mysql
EXPLAIN SELECT ... FROM ... WHERE ... ORDER BY ... GROUP BY ... JOIN ...;

EXPLAIN INSERT INTO ... SELECT ...; -- 查看 INSERT SELECT 的执行计划
EXPLAIN UPDATE ... WHERE ...;      -- 查看 UPDATE 的执行计划
EXPLAIN DELETE FROM ... WHERE ...; -- 查看 DELETE 的执行计划
```

**EXPLAIN 输出的关键列 (重点关注):**

`EXPLAIN` 会输出一个表格，每一行代表查询中的一个操作步骤（通常对应一个表）。重要的列包括：

- **`id`**: 查询的标识符。在复杂查询（如子查询、UNION）中，可能有多个 `id`，表示不同的执行顺序或步骤。
- **`select_type`**: 查询类型。常见的有：
    - `SIMPLE`: 简单的 SELECT 查询，不包含 UNION 或子查询。
    - `PRIMARY`: 复杂查询中最外层的 SELECT。
    - `SUBQUERY`: 在 SELECT 或 WHERE 子句中的子查询。
    - `DERIVED`: 在 FROM 子句中的子查询（派生表）。
    - `UNION`: UNION 中的第二个及后续的 SELECT。
- **`table`**: 当前操作涉及的表。
- **`type`**: **访问类型 (非常重要!)**。表示 MySQL 如何查找表中的行。从最优到最差大致顺序：
    - `system`: 表只有一行（=系统表）。
    - `const`: 通过主键或唯一索引等值查找，最多匹配一行。速度极快。
    - `eq_ref`: JOIN 时，对前一个表的结果的每一行，通过主键或唯一非空索引等值查找，最多匹配一行。效率高。
    - `ref`: JOIN 时，对前一个表的结果的每一行，通过非唯一索引或允许为 NULL 的唯一索引等值查找，可能匹配多行。
    - `range`: 对索引进行范围扫描（>, <, >=, <=, BETWEEN, IN 等）。
    - `index`: 全索引扫描，只遍历索引树。比 `ALL` 快（不需要回表）。
    - `ALL`: **全表扫描**。遍历表中的所有行。速度最慢，尤其在数据量大时应尽量避免。
- **`possible_keys`**: 可能用到的索引列表。MySQL 可能会从这些索引中选择。
- **`key`**: **实际使用的索引**。如果为 `NULL`，表示没有使用索引。
- **`key_len`**: 使用的索引的长度（字节）。对于联合索引，可以看出来使用了联合索引的哪几列。
- **`ref`**: 与索引一起使用的列或常量。
- **`rows`**: **预估需要读取的行数 (非常重要!)**。这是 MySQL 认为为了找到结果需要检查的行数。这个数字越小越好。大的 `rows` 值通常伴随着 `ALL` 或 `index` 类型，是性能问题的强烈信号。
- **`Extra`**: **额外信息 (非常重要!)**。包含不适合在其他列中显示的重要信息。常见的有：
    - `Using index`: **覆盖索引**。查询只需要访问索引即可获取所需列，无需回表。效率高。
    - `Using where`: 使用了 `WHERE` 子句过滤数据。
    - `Using temporary`: 使用了临时表来处理查询（通常用于 `GROUP BY` 或 `ORDER BY`，且无法通过索引直接满足）。可能导致性能问题。
    - `Using filesort`: **使用文件排序**（无法利用索引进行排序）。MySQL 需要对结果进行额外的排序操作。可能导致性能问题。
    - `Using join buffer`: JOIN 操作时使用了 JOIN 缓冲区。
    - `Range checked for each record`: 没有找到好的索引，对于每一行都需要进行范围检查。

**如何分析执行计划：**
主要看 `type`、`rows` 和 `Extra` 这三列：

- **`type`**: 优先追求 `const`, `eq_ref`, `ref`, `range`。尽量避免 `ALL` 和 `index` (除非是覆盖索引或表很小)。
- **`rows`**: 越小越好。大的 `rows` 值通常表示全表扫描或索引效率低下。
- **`Extra`**: 关注是否有 `Using filesort`, `Using temporary`。如果能看到 `Using index` 通常是好事。

**价值：**
通过分析 `EXPLAIN` 输出，你可以快速发现：
- 是否遗漏了索引。
- 索引是否失效。
- 查询是否导致全表扫描。
- JOIN 的顺序是否合理。
- 是否产生了不必要的临时表或文件排序。

**简记：** **看懂 MySQL 怎么查数据**的工具。命令是 `EXPLAIN SQL语句`。**重点看 `type`, `rows`, `Extra`**。帮你发现**没用索引、全表扫描、排序慢**等问题。

---
## 进阶学习
### 视图

**概念：**
- **视图(View)是一种虚拟存在的表。** 视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

**语法：**
- `create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded | local] check potion];`
	- `[or replace]` ：如果存在则替换
	- `[with [cascaded | local] check potion]` ：在该视图执行命令时检查是否符合创建时指定的查询条件，以避免无法显示操作的情况；
		- `cascaed`：检查当前及所有带 CHECK OPTION 的相关视图。
		- `local` ：只检查当前视图。

**作用：**
1. 简单
	- 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。
	- 那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。
2. 安全
	- 数据库可以授权，但不能授权到数据库特定行和特定的列上。
	- 通过视图用户只能查询和修改他们所能见到的数据
3. 数据独立
	- 视图可帮助用户屏蔽真实表结构变化带来的影响，


---
### 存储过程
**概念：**
- 存储过程是事先经过编译并存储在数据库中的一段 SOL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
- 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。

**语法：**
- 创建
	`create procedure 存储过程名称([参数列表]) begin sql语句 end;`
- 调用
	`call 名称([参数]);`
- 查看
	- 查询指定数据库的存储过程及状态信息
		`selecr * from information_schema.routines where routine_schema='xxx';`
	- 查询某个存储过程的定义
		`show create procedure 存储过程名称;`
- 删除
	`drop procedure [id exists] 存储过程名称;`

---
### 触发器
**概念：**
- 触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作
- 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。

---
### 锁
**概念：**
- 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I/0)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。













### 高级函数
###### `MATCH()` 和 `AGAINST()` 函数
- 这两个函数是 MySQL 中用于执行全文搜索的核心函数，它们总是配合使用。

1. **`MATCH(column1, column2, ...)` 函数:**
    - **含义：** 这个函数指定你要在哪些**已经建立了全文索引的列**中进行搜索。
    - **作用：** 它告诉 MySQL 搜索的“范围”是在哪些列里。括号里列出的列必须是你在创建全文索引时包含的列。你可以列出一个或多个列。
    
2. **`AGAINST('search_query' [IN search_mode])` 函数:**
    - **含义：** 这个函数指定你要搜索的**查询字符串（关键词或短语）**以及**搜索模式**。
    - **作用：** 它提供具体的搜索内容和搜索方式。
        - `'search_query'`: 你输入的关键词或短语。
        - `[IN search_mode]`: 可选参数，指定搜索模式，比如 `IN NATURAL LANGUAGE MODE`, `IN BOOLEAN MODE`, `WITH QUERY EXPANSION`。如果不指定，默认为自然语言模式。
    - **扩展：**`AGAINST()` 函数有不同的搜索模式：

		1. **`NATURAL LANGUAGE MODE` (自然语言模式):** 这是默认模式。根据词语的相关性进行搜索和排序。
		
		   ```mysql
	SELECT title, body, MATCH(title, body) AGAINST('database MySQL') AS score
    FROM articles
    WHERE MATCH(title, body) AGAINST('database MySQL'); 
    -- 可以省略 MODE IN NATURAL LANGUAGE
    -- `score` 列表示相关性得分。
```
    
		2. **`BOOLEAN MODE` (布尔模式):** 使用特定的布尔运算符来控制搜索逻辑。
    
    ``` mysql
    -- 查找包含 'database' 但不包含 'MySQL' 的文章
    SELECT title, body FROM articles
    WHERE MATCH(title, body) AGAINST('+database -MySQL' IN BOOLEAN MODE);
    
    -- 查找包含 'database' 且包含 'MySQL' 的文章
    SELECT title, body FROM articles
    WHERE MATCH(title, body) AGAINST('+database +MySQL' IN BOOLEAN MODE);
    ```
    
    - 常用的布尔运算符： 
	    1. `+`: 必须包含该词语 
	    2. `-`: 必须排除该词语 
	    3. `>` `<`: 提高或降低该词语在结果中的相关性排名 
	    4. `*`: 通配符，匹配以某个前缀开头的词语 (例如 `data*` 匹配 database, data...) 
	    5. `""`: 将短语作为一个整体进行搜索 (例如 `"relational database"`)
    
	3. **`WITH QUERY EXPANSION` (查询扩展模式):** 先进行一次自然语言搜索，然后根据第一次搜索的相关结果，找出更多相关的词语进行第二次搜索。
    
    ```mysql
    SELECT title, body FROM articles
    WHERE MATCH(title, body) AGAINST('database' WITH QUERY EXPANSION);
    ```
---
###### substring()函数
- `substring(column_name,10,2)`
- 表示将column字段上的字符从第10位开始截取2位（1开始数）